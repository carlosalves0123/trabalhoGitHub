<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Sistema Operacional - Eduvale</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">


</head>

<body>

    <div class="container">

        <div class="row">
            <div class="col-12">
                <h1 class="alert alert-info text-center">Aulas de Sistemas Operacionais</h1>
            </div>
        </div>



        <div class="row">
            <div class="col-3">

                <div class="list-group">
                    <a href="index.html" class="list-group-item ">Visão Geral dos Sistemas Operacionais</a>
                    <a href="evolucao.html" class="list-group-item">A Evolução dos Sistemas Operacionais</a>
                    <a href="ocorrencias.html" class="list-group-item">Concorrência</a>
                    <a href="estrutura.html" class="list-group-item">Estrutura do Sistema Operacional</a>
                    <a href="processo.html" class="list-group-item">Processo</a>
                    <a href="thread.html" class="list-group-item">Thread</a>
                    <a href="sincronizacao.html" class="list-group-item">Sincronização e Comunicação de Processos</a>
                    <a href="gerencia_processador.html" class="list-group-item">Gerencia do Processador</a>
                    <a href="gerencia_memoria.html" class="list-group-item active">Gerência de Memória</a>
                    <a href="gerencia_dispositivos.html" class="list-group-item">Gerencia de dispositivos</a>
                    <a href="gerencia_arquivos.html" class="list-group-item">Gerência de Sistema de Arquivos</a>
                    <a href="multiplos_processarores.html" class="list-group-item">Sistemas com múltiplos processadores</a>
                </div>
            </div>

            <div class="col-9">
                <h2 class="text-center alert alert-secondary">Gerência de Memória 2</h2>

                <h3> Introdução</h3>
                <ul>
                    <li>Na memória principal residem os programas em execução.</li>

                    <li>Memória secundária são mecanismos de armazenamento permanente, são mais abundantes e baratas.</li>
                    <li>Para um programa ser executado deve ser carregado na memória principal.</li>
                    <li>Gerenciamento complexo em sistemas multiprogramáveis com múltiplos usuários utilizando-a eficientemente.</li>
                </ul>
                <h3> Alocação Contígua Simples</h3>
                <ul>
                    <li>Implementada nos primeiros Sistemas Operacionais e ainda existentes em alguns sistemas monoprogramáveis.</li>
                    <li>Memória dividida em duas partes, Sistema Operacional e programa do usuário.</li>
                    <li>O programador tem controle sobre toda a memória principal, podendo acessar qualquer posição da memória, inclusive onde está residente o Sistema Operacional.</li>
                    <li>Um mecanismo de proteção utilizado é delimitar a área do Sistema Operacional que delimita a área do mesmo.</li>
                    <li>Fácil implementação e código reduzido, porém Ineficiência no uso do processador e da memória pois apenas um usuário pode dispor desse recurso.</li>
                    <li>Programas limitados ao tamanho da memória disponível.</li>
                    <li>Overlay (sobreposição) – Solução encontrada para dividir o programa em partes (módulos), de forma que pudessem executar independentemente uma da outra, utilizando uma mesma área de memória.</li>
                    <li>A definição das áreas de Overlay são de responsabilidade do programador através de comandos específicos da linguagem utilizada.</li>
                </ul>
                <h3> Alocação Particionada</h3>
                <ul>
                    <li>A eficiência da multiprogramação exige que vários programas estejam na memória ao mesmo tempo, vindo a necessidade de organização da memória.</li>
                </ul>


                <h4>Alocação Particionada Estática:</h4>
                <ul>
                    <li>Divisão da memória em tamanhos fixos (partições) definidos na inicialização do Sistema em função dos programas que executariam no ambiente.</li>
                    <li>A alteração do tamanho de uma partição necessita a inicialização do Sistema Operacional.</li>
                    <li>Os programas só podiam executar em uma das partições, mesmo com outras disponíveis.</li>
                    <li>Limitações impostas pelos compiladores e montadores que geravam apenas códigos absolutos.</li>
                    <li>Posteriormente, evolução dos compiladores, linkers e loaders com geração de código realocável, sendo que os programas puderam ser carregados em qualquer partição (alocação particionada estática realocável).</li>
                    <li>Surgimento da tabela de partições com informações de tamanho, uso e delimitações.</li>
                    <li>Proteção da memória através de dois registradores, início e fim da partição.</li>
                    <li>Os programas não preenchiam totalmente as partições onde eram carregados.</li>
                    <li>Problemas de fragmentação.</li>
                </ul>

                <h4>Alocação Particionada Dinâmica</h4>
                <ul>
                    <li>Aumento do grau de compartilhamento diminuindo o problema da fragmentação.</li>
                    <li>Partições sem tamanho fixo, onde cada programa utiliza o espaço que necessita.</li>
                    <li>Existe ainda o problema de fragmentação, conforme os programas vão terminando e deixando espaços cada vez menores.</li>
                    <li>Soluções para resolver o problema de fragmentação:</li>
                    <ul>
                        <li>Primeira – Reunir os espaços adjacentes, produzindo um único espaço de tamanho maior.</li>
                        <li>Segunda – Realocação de todas as partições ocupadas, eliminando todos os espaços entre elas (alocação dinâmica com realocação), porém, aumentando a complexibilidade do algoritmo e consumindo mais recursos do sistema.</li>
                    </ul>
                </ul>
                <h4>Estratégias para Escolha da Partição</h4>
                <ul>
                    <li>Função para determinar em qual partição livre um programa será carregado para execução.</li>
                    <li>Função de evitar, ou diminuir, o problema da fragmentação antes que ele ocorra.</li>
                    <li>O tamanho do programa é o fator mais importante para a adoção da melhor estratégia.</li>
                    <li>Best-fit:</li>
                    <ul>
                        <li>Escolhe a melhor partição, ou seja, aquela que o programa deixa o menor espaço sem utilização.</li>
                        <li>Lista de áreas livres alocada por tamanho, diminuindo o tempo de busca</li>
                        <li>Desvantagem de deixar pequenas áreas não contíguas, aumentando o problema da fragmentação.</li>
                    </ul>
                    <li>Worst-fit:</li>
                    <ul>
                        <li>Escolhe a pior partição, ou seja, aquela que o programa deixa o maior espaço sem utilização.</li>
                        <li>Diminui o problema de fragmentação, deixando espaços livres maiores que permitem a um maior número de programas utilizar a memória.</li>
                    </ul>
                    <li>First-fit:</li>
                    <ul>
                        <li>Escolhe a primeira partição livre de tamanho suficiente para carregar o programa</li>
                        <li> Lista de áreas livres ordenada por endereços crescentemente.</li>
                        <li>Grande chance de se obter uma grande partição livre nos endereços de memórias mais altos.</li>
                        <li>Mais rápida e consome menos recursos do sistema.</li>
                    </ul>
                </ul>
                <h3> Swapping</h3>
                <ul>
                    <li>Tenta resolver o problema de insuficiência da memória para todos os usuários.</li>
                    <li>Aloca espaço para programas que esperam por memória livre para serem processados.</li>
                    <li>O sistema escolhe um programa residente, que é levado da memória para o disco (swap out), retornando posteriormente para a memória principal (swap in) como se nada tivesse ocorrido.</li>
                    <li>Problema da realocação dos programas. O loader realocável permite que um programa seja colocado em qualquer posição da memória, porém a realocação é realizada no momento do carregamento.</li>
                    <li>Mecanismo ineficiente em função do tempo gasto para carregamento.</li>
                    <li>Uma alternativa é esperar que a região de memória usada pelo programa na ocasião do seu primeiro carregamento esteja disponível.</li>
                    <li>Realocação Dinâmica:</li>
                    <ul>
                        <li>É a melhor solução, uma implementação no hardware dos computadores, permitindo que a realocação seja realizada durante a execução do programa.</li>
                        <li>Realizada através de um registrador especial denomidado registrador de alocação, que recebe o endereço inicial da região da memória que o programa irá ocupar no momento do carregamento do programa na memória.</li>
                        <li>Toda vez que ocorrer uma referência a algum endereço, o endereço contido na instrução será somado ao conteúdo do registrador, gerando assim, o endereço físico.</li>
                    </ul>
                    <li>Essencial para a implementação de um sistema multiprogramável.</li>
                    <li>Permitiu um maior throughput através de um maior compartilhamento da memória.</li>
                    <li>Mais eficiente para programas onde existiam poucos usuários competindo por memória e em ambientes que trabalhavam com aplicações pequenas.</li>
                    <li>Seu maior problema é o elevado custo das operações de entrada/saída (swapped in/out).</li>
                </ul>
                <h3> Memória Virtual</h3>
                <ul>
                    <li>Combina memória principal e secundária;</li>
                    <li>Impressão da memória ser muito maior do que é;</li>
                    <li>Desvinculação do endereçamento feito pelo programa dos endereços físicos da memória principal;</li>
                    <li>Procura minimizar o problema de fragmentação da memória.</li>
                </ul>
                <h4>Espaço de Endereçamento Virtual</h4>
                <ul>
                    <li>Conceito próximo a vetores em linguagens de alto nível;</li>
                    <li>Referência a um componente do vetor sem preocupação com a posição da memória onde o dado está;</li>
                    <li>Programa no ambiente de memória virtual não faz referência a endereços físicos de memória (endereços reais), mas apenas a endereços virtuais;</li>
                    <li>Mapeamento – é a tradução do endereço virtual para o físico;</li>
                    <li>Espaço de endereçamento virtual – é o conjunto de endereços virtuais que os processos podem endereçar.</li>
                    <li>Espaço de endereçamento real – é o conjunto de endereços reais.</li>
                    <li>Apenas parte do programa pode estar residente na memória em um determinado instante;</li>
                    <li>O Sistema Operacional utiliza a memória secundária como uma extensão da memória principal.</li>
                </ul>
                <h4>Mapeamento</h4>
                <ul>
                    <li>Mecanismo que transforma os endereços virtuais em endereços reais;</li>
                    <li>Todo programa precisa estar no espaços de endereçamento real para poder ser referenciado ou executado;</li>
                    <li>Atualmente, o mapeamento é realizado via hardware junto com o Sistema Operacional, de forma a não comprometer seu desempenho e torná-lo transparente aos 